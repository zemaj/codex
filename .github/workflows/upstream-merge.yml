name: Upstream Merge

on:
  # Poll upstream regularly; also allow manual and external triggers
  schedule:
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      upstream_repo:
        description: 'Upstream repo (owner/name)'
        required: false
        default: 'openai/codex'
      upstream_branch:
        description: 'Upstream branch'
        required: false
        default: 'main'
  repository_dispatch:
    types: [upstream-push]

concurrency:
  group: upstream-merge
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

env:
  UPSTREAM_REPO: ${{ inputs.upstream_repo || 'openai/codex' }}
  UPSTREAM_BRANCH: ${{ inputs.upstream_branch || 'main' }}
  MERGE_BRANCH: upstream-merge
  RG_VERSION: '14.1.0'
  JQ_VERSION: '1.7.1'

jobs:
  merge:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Check out repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Configure authenticated origin for pushes
        env:
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git"

      - name: Set git identity for commits
        run: |
          git config user.name "just-every-code"
          git config user.email "code@justevery.com"
          git config --global --add safe.directory "$GITHUB_WORKSPACE"

      - name: "Quick no-op: ancestor checks for default and upstream-merge"
        id: check_upstream
        shell: bash
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" 2>/dev/null || true
          # Fetch exact refs with commit graph, no blobs, to make ancestor checks reliable and fast.
          git fetch --no-tags --prune --filter=blob:none origin \
            "+refs/heads/${DEFAULT_BRANCH}:refs/remotes/origin/${DEFAULT_BRANCH}" \
            "+refs/heads/upstream-merge:refs/remotes/origin/upstream-merge" || true
          git fetch --no-tags --prune --filter=blob:none upstream \
            "+refs/heads/${UPSTREAM_BRANCH}:refs/remotes/upstream/${UPSTREAM_BRANCH}"
          # Extra short-circuit: if origin/upstream-merge already contains both current tips.
          if git ls-remote --exit-code --heads origin upstream-merge >/dev/null 2>&1; then
            if git merge-base --is-ancestor "upstream/${UPSTREAM_BRANCH}" "origin/upstream-merge" \
               && git merge-base --is-ancestor "origin/${DEFAULT_BRANCH}" "origin/upstream-merge"; then
              echo "skip=true" >> "$GITHUB_OUTPUT"
              echo "Upstream and default are already included in origin/upstream-merge; skipping agent run."
              exit 0
            fi
          fi
          # If upstream tip is already an ancestor of default, nothing to merge.
          if git merge-base --is-ancestor "upstream/${UPSTREAM_BRANCH}" "origin/${DEFAULT_BRANCH}"; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "No new upstream commits; skipping agent run."
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      # Expensive setup only runs if we are not skipping.
      - name: Setup Rust toolchain (match repo)
        if: steps.check_upstream.outputs.skip != 'true'
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.89.0

      - name: Add local bin to PATH
        if: steps.check_upstream.outputs.skip != 'true'
        run: |
          mkdir -p "$HOME/.local/bin"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Cache ripgrep binary
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: ~/.local/tools/rg-${{ env.RG_VERSION }}
          key: rg-${{ runner.os }}-${{ env.RG_VERSION }}

      - name: Setup ripgrep (cached)
        if: steps.check_upstream.outputs.skip != 'true'
        run: |
          set -euo pipefail
          if command -v rg >/dev/null 2>&1; then rg --version; exit 0; fi
          mkdir -p "$HOME/.local/tools" "$HOME/.local/bin"
          if [ ! -x "$HOME/.local/tools/rg-${RG_VERSION}/rg" ]; then
            cd "$HOME/.local/tools"
            TARBALL="ripgrep-${RG_VERSION}-x86_64-unknown-linux-musl.tar.gz"
            URL="https://github.com/BurntSushi/ripgrep/releases/download/${RG_VERSION}/${TARBALL}"
            curl -sSL "$URL" -o "$TARBALL"
            tar -xzf "$TARBALL"
            rm -f "$TARBALL"
            mv "ripgrep-${RG_VERSION}-x86_64-unknown-linux-musl" "rg-${RG_VERSION}"
          fi
          install -m 0755 "$HOME/.local/tools/rg-${RG_VERSION}/rg" "$HOME/.local/bin/rg"
          rg --version

      - name: Cache jq binary
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: ~/.local/tools/jq-${{ env.JQ_VERSION }}
          key: jq-${{ runner.os }}-${{ env.JQ_VERSION }}

      - name: Setup jq (cached)
        if: steps.check_upstream.outputs.skip != 'true'
        run: |
          set -euo pipefail
          if command -v jq >/dev/null 2>&1; then jq --version; exit 0; fi
          mkdir -p "$HOME/.local/tools/jq-${JQ_VERSION}" "$HOME/.local/bin"
          URL="https://github.com/jqlang/jq/releases/download/jq-${JQ_VERSION}/jq-linux-amd64"
          curl -sSL "$URL" -o "$HOME/.local/tools/jq-${JQ_VERSION}/jq"
          chmod +x "$HOME/.local/tools/jq-${JQ_VERSION}/jq"
          install -m 0755 "$HOME/.local/tools/jq-${JQ_VERSION}/jq" "$HOME/.local/bin/jq"
          jq --version

      # Remove slow apt install; we now use cached static binaries for rg/jq

      - name: Cache Rust build (cargo + target)
        if: steps.check_upstream.outputs.skip != 'true'
        uses: Swatinem/rust-cache@v2
        with:
          # Our Rust workspace lives in codex-rs; cache its target dir
          workspaces: |
            codex-rs -> target
          save-if: true

      # Belt-and-suspenders: explicit cache of the target directory keyed by toolchain + lockfile
      - name: Cache cargo target (direct)
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: codex-rs/target
          key: target-${{ runner.os }}-toolchain-1.89.0-${{ hashFiles('codex-rs/Cargo.lock') }}-devfast
          restore-keys: |
            target-${{ runner.os }}-toolchain-1.89.0-

      - name: Cache Cargo registry (CARGO_HOME in runner temp)
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ runner.temp }}/cargo-home/registry
            ${{ runner.temp }}/cargo-home/git
          key: cargo-home-${{ runner.os }}-toolchain-1.89.0-${{ hashFiles('codex-rs/Cargo.lock') }}
          restore-keys: |
            cargo-home-${{ runner.os }}-toolchain-1.89.0-
            cargo-home-${{ runner.os }}-

      - name: Setup Node.js
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache npm (npx) downloads
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
          key: npm-cache-${{ runner.os }}-node20-${{ hashFiles('**/package-lock.json', '**/pnpm-lock.yaml', '**/yarn.lock') }}
          restore-keys: |
            npm-cache-${{ runner.os }}-node20-

      - name: Start local OpenAI proxy (no key to agent)
        if: steps.check_upstream.outputs.skip != 'true'
        id: openai_proxy
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "OPENAI_API_KEY secret is required to start the proxy." >&2
            exit 1
          fi
          mkdir -p .github/auto
          cat > .github/auto/openai-proxy.js <<'JS'
          const http = require('http');
          const https = require('https');
          const { URL } = require('url');
          const PORT = process.env.PORT || 5055;
          const API_KEY = process.env.OPENAI_API_KEY || '';
          const ALLOWED = ['/v1/chat/completions','/v1/responses'];
          if (!API_KEY) { console.error('OPENAI_API_KEY missing'); process.exit(1); }
          const server = http.createServer((req, res) => {
            if (req.method !== 'POST' || !ALLOWED.some(p => req.url.startsWith(p))) {
              res.writeHead(403, { 'content-type': 'application/json' });
              res.end(JSON.stringify({ error: 'blocked' }));
              return;
            }
            const chunks = [];
            req.on('data', c => { chunks.push(c); if (Buffer.concat(chunks).length > 1024*1024) req.destroy(); });
            req.on('end', () => {
              const up = new URL('https://api.openai.com' + req.url);
              const fw = https.request({
                method: 'POST',
                hostname: up.hostname,
                path: up.pathname + up.search,
                headers: { 'content-type': 'application/json', 'authorization': `Bearer ${API_KEY}` }
              }, r => { res.writeHead(r.statusCode || 500, r.headers); r.pipe(res); });
              fw.on('error', e => { res.writeHead(502, {'content-type':'application/json'}); res.end(JSON.stringify({ error:'upstream', message: e.message })); });
              fw.end(Buffer.concat(chunks));
            });
          });
          server.listen(PORT, '127.0.0.1', () => { console.log('proxy listening on 127.0.0.1:'+PORT); });
          JS
          node .github/auto/openai-proxy.js > .github/auto/openai-proxy.log 2>&1 &
          echo "pid=$!" >> "$GITHUB_OUTPUT"

      - name: Prepare agent context (commit range, deleted paths, histogram)
        id: prep
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          set -x
          mkdir -p .github/auto
          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" 2>/dev/null || true
          # Fetch with commit graph but no blobs for speed; ensure sufficient history for merge-base
          git fetch --no-tags origin --prune --filter=blob:none
          git fetch --no-tags upstream --prune --filter=blob:none "${UPSTREAM_BRANCH}"
          RANGE="upstream/${UPSTREAM_BRANCH} ^origin/${DEFAULT_BRANCH}"
          : > .github/auto/COMMITS.json
          echo '[' >> .github/auto/COMMITS.json
          first=1
          while read -r sha; do
            title=$(git log -1 --pretty=%s "$sha" | sed 's/"/\\"/g')
            date=$(git log -1 --pretty=%cI "$sha")
            files=$(git show --pretty=format: --name-only "$sha" | sed '/^$/d')
            files_json=$(printf '%s\n' "$files" | jq -Rcs 'split("\n") | map(select(length>0))')
            stats=$(git show --shortstat --oneline "$sha" | tail -n1)
            ins=$(printf '%s' "$stats" | sed -n 's/.* \([0-9]\+\) insertions\?.*/\1/p')
            del=$(printf '%s' "$stats" | sed -n 's/.* \([0-9]\+\) deletions\?.*/\1/p')
            ins=${ins:-0}; del=${del:-0}
            [ $first -eq 1 ] || echo ',' >> .github/auto/COMMITS.json
            first=0
            jq -n --arg sha "$sha" --arg title "$title" --arg date "$date" \
                 --argjson files "$files_json" --argjson insertions "$ins" --argjson deletions "$del" \
                 '{sha:$sha,title:$title,date:$date,files:$files,insertions:($insertions|tonumber),deletions:($deletions|tonumber)}' >> .github/auto/COMMITS.json
          done < <(git rev-list --reverse $RANGE)
          echo ']' >> .github/auto/COMMITS.json
          if jq -e 'length==0' .github/auto/COMMITS.json >/dev/null 2>&1; then
            echo "No upstream commits beyond default; context prepared (empty).";
          fi

          git ls-tree -r --name-only "origin/${DEFAULT_BRANCH}" | awk -F'/' '/^codex-rs\//{print $1"/"$2}' | sort -u > .github/auto/DEFAULT_CRATES.txt
          git ls-tree -r --name-only "upstream/${UPSTREAM_BRANCH}" | awk -F'/' '/^codex-rs\//{print $1"/"$2}' | sort -u > .github/auto/UPSTREAM_CRATES.txt
          comm -13 .github/auto/DEFAULT_CRATES.txt .github/auto/UPSTREAM_CRATES.txt > .github/auto/DELETED_ON_DEFAULT.txt || true

          git diff --name-only "origin/${DEFAULT_BRANCH}..upstream/${UPSTREAM_BRANCH}" > .github/auto/DELTA_FILES.txt || true
          awk 'BEGIN{tui=cli=core=docs=tests=other=0}
               /^codex-rs\/tui\//{tui++; next}
               /^codex-cli\//{cli++; next}
               /^codex-rs\/(core|common|protocol|exec|file-search)\//{core++; next}
               /^docs\//{docs++; next}
               /(^|\/)tests?\//{tests++; next}
               {other++}
               END{printf("tui=%d cli=%d core=%d docs=%d tests=%d other=%d\n",tui,cli,core,docs,tests,other)}' \
            .github/auto/DELTA_FILES.txt > .github/auto/CHANGE_HISTOGRAM.txt

          FILES_COUNT=$(wc -l < .github/auto/DELTA_FILES.txt | tr -d ' ')
          LOC_EST=$(git diff --shortstat "origin/${DEFAULT_BRANCH}..upstream/${UPSTREAM_BRANCH}" | awk '{for(i=1;i<=NF;i++){if($i=="insertions(+)")ins=$(i-1); if($i=="deletions(-)")del=$(i-1)} } END{print (ins?ins:0)+(del?del:0)}')
          MERGE_MODE=one-shot
          if [ "${FILES_COUNT:-0}" -gt 800 ] || [ "${LOC_EST:-0}" -gt 15000 ]; then MERGE_MODE=by-bucket; fi
          echo "merge_mode=${MERGE_MODE}" >> "$GITHUB_OUTPUT"
          echo "files_count=${FILES_COUNT}" >> "$GITHUB_OUTPUT"
          echo "loc_est=${LOC_EST}" >> "$GITHUB_OUTPUT"

          git diff --stat "origin/${DEFAULT_BRANCH}..upstream/${UPSTREAM_BRANCH}" > .github/auto/DIFFSTAT.txt || true

          # Detect reintroduced paths: present in merge-base, absent on default, present on upstream
          MB=$(git merge-base "origin/${DEFAULT_BRANCH}" "upstream/${UPSTREAM_BRANCH}" 2>/dev/null || true)
          : > .github/auto/REINTRODUCED_PATHS.txt
          if [ -n "${MB:-}" ]; then
            while read -r status path; do
              [ "${status}" = "A" ] || continue
              if git ls-tree -r --name-only "$MB" -- "$path" >/dev/null 2>&1 && \
                 git ls-tree -r --name-only "$MB" -- "$path" | grep -q . && \
                 ! git ls-tree -r --name-only "origin/${DEFAULT_BRANCH}" -- "$path" | grep -q .; then
                echo "$path" >> .github/auto/REINTRODUCED_PATHS.txt
              fi
            done < <(git diff --name-status "origin/${DEFAULT_BRANCH}..upstream/${UPSTREAM_BRANCH}" || true)
          else
            echo "No merge-base between origin/${DEFAULT_BRANCH} and upstream/${UPSTREAM_BRANCH}; skipping reintroduced path detection." >> .github/auto/CHANGE_HISTOGRAM.txt
          fi
          if [ -z "${MB:-}" ]; then echo "no_merge_base=true" >> "$GITHUB_OUTPUT"; else echo "no_merge_base=false" >> "$GITHUB_OUTPUT"; fi

      - name: Reset remote merge branch to default tip (preserve PR)
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          # Ensure remote branch does not carry unrelated history from prior runs
          git fetch --no-tags origin --depth=1
          git checkout -B upstream-merge "origin/${DEFAULT_BRANCH}"
          # Force-with-lease so the PR stays open but branch tip is clean
          git push --force-with-lease origin HEAD:upstream-merge

      - name: Ensure upstream-merge mirrors default when skipping (prevent stale PRs)
        if: steps.check_upstream.outputs.skip == 'true'
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          git fetch --no-tags origin --depth=1
          git checkout -B upstream-merge "origin/${DEFAULT_BRANCH}"
          git push --force-with-lease origin HEAD:upstream-merge

      - name: Run Code agent to perform upstream merge
        id: agent
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          MERGE_BRANCH: ${{ env.MERGE_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          MERGE_MODE: ${{ steps.prep.outputs.merge_mode || 'one-shot' }}
          OURS_GLOBS: |
            codex-rs/tui/**
            codex-cli/**
            .github/workflows/**
            AGENTS.md
            README.md
            CHANGELOG.md
        run: |
          set -euo pipefail
          SAFE_PATH="$PATH"; SAFE_HOME="$HOME"
          # Build the agent prompt safely without command substitution
          {
            printf 'Context\n- UPSTREAM_REPO=%s\n- UPSTREAM_BRANCH=%s\n- MERGE_BRANCH=%s\n- DEFAULT_BRANCH=%s\n\n' \
              "$UPSTREAM_REPO" "$UPSTREAM_BRANCH" "$MERGE_BRANCH" "$DEFAULT_BRANCH";
            echo 'Runtime'; echo '- ENV: github-actions'; echo "- MERGE_MODE=${MERGE_MODE}"; echo '';
            echo 'Goals';
            echo '- Keep our fork in sync with upstream by incorporating genuine improvements.';
            echo '- Do not overwrite our unique TUI and tooling approach unless clearly beneficial and compatible.';
            echo '- Make granular decisions commit-by-commit or by bucket; do not blanket-drop upstream changes without review.';
            echo '';
            echo 'Artifacts';
            echo '- .github/auto/COMMITS.json: upstream commits not in default (sha, title, files, stats).';
            echo '- .github/auto/DELETED_ON_DEFAULT.txt: crates/paths removed on our default; avoid re-introducing.';
            echo '- .github/auto/CHANGE_HISTOGRAM.txt: rough areas touched.';
            echo '- .github/auto/DELTA_FILES.txt and DIFFSTAT.txt: filenames and summary.';
            echo '- .github/auto/REINTRODUCED_PATHS.txt: candidate paths removed previously that upstream reintroduced.';
            echo '<policy>';
            # Emit a minimized JSON policy for clarity (drop empty sections)
            if command -v jq >/dev/null 2>&1; then
              jq 'del(.prefer_theirs_globs) | with_entries(select(.value|type != "array" or (.value|length>0)))' .github/merge-policy.json 2>/dev/null || cat .github/merge-policy.json || echo '{ }'
            else
              cat .github/merge-policy.json 2>/dev/null || echo '{ }'
            fi
            echo '</policy>';
            cat << 'EOP'
          <task>
          You are the maintainer bot. Perform an upstream merge using our repo policies and a selective reconciliation strategy.
          Steps:
          1) Ensure remote `upstream` points to the UPSTREAM_REPO in Context. Fetch origin and upstream.
          2) Write .github/auto/MERGE_PLAN.md summarizing strategy (one-shot, by-bucket, or per-commit) based on MERGE_MODE and artifacts.
          3) Re-create branch MERGE_BRANCH from origin/DEFAULT_BRANCH.
          4) Merge upstream/UPSTREAM_BRANCH using `--no-commit`.
             - Use the <policy> JSON for prefer_ours_globs and purge_globs (prefer_theirs_globs is intentionally empty).
             - Keep ours by default. Do NOT attempt to realign or reintroduce crates/dirs we removed locally.
             - For files matching prefer_ours_globs: keep ours; if upstream added new files under these globs that we donâ€™t have, prefer deletion.
             - For any path listed in purge_globs: ensure it remains deleted if upstream reintroduced it.
             - Review the upstream commit range (e.g., via `git rev-list upstream/UPSTREAM_BRANCH ^origin/DEFAULT_BRANCH`). For each upstream commit, use repo context and history to judge whether to incorporate or to keep ours. Prefer preserving our local intent and removals; incorporate upstream when it improves correctness, security, or compatibility without violating protected areas (themes/UX/docs/workflows). Record notable decisions in MERGE_REPORT.md.
          5) Stage and commit with a conventional message and short build status.
          6) Run ./build-fast.sh (warnings treated as failures). Apply minimal safe fixes only.
          7) Write .github/auto/MERGE_REPORT.md (Incorporated / Dropped / Other changes) summarizing choices.
          8) Push MERGE_BRANCH and prepare PR title/body.
          </task>

          <constraints>
          - Be minimal and surgical; do not refactor.
          - Keep diffs focused on merge and required fixes. Do not recreate locally removed theming/UX files.
          - Never rewrite git history outside the merge branch.
          - If Git reports no merge-base between origin/DEFAULT_BRANCH and upstream/UPSTREAM_BRANCH, you may use `--allow-unrelated-histories` to graft histories and proceed with all policies/guards.
          - If the initial `git merge --no-ff --no-commit upstream/UPSTREAM_BRANCH` fails with unrelated histories, re-run the merge in a separate command with `--allow-unrelated-histories` (do not chain with `||`).
          - Use only the provided GH_TOKEN for push; do not echo it.
          </constraints>
          EOP
          } | env -i PATH="$SAFE_PATH" HOME="$SAFE_HOME" \
            OPENAI_API_KEY="x" \
            OPENAI_BASE_URL="http://127.0.0.1:5055/v1" \
            OPENAI_API_BASE="http://127.0.0.1:5055/v1" \
            GH_TOKEN="$GH_TOKEN" \
            npm_config_cache="$SAFE_HOME/.npm" \
            npx -y @just-every/code@latest \
            exec \
            -s workspace-write \
            -c sandbox_workspace_write.allow_git_writes=true \
            -c sandbox_workspace_write.network_access=true \
            -c shell_environment_policy.r#set.CARGO_HOME="${RUNNER_TEMP}/cargo-home" \
            -c shell_environment_policy.r#set.CARGO_TARGET_DIR="${GITHUB_WORKSPACE}/codex-rs/target" \
            --cd "$GITHUB_WORKSPACE" \
            --skip-git-repo-check \
            - | tee .github/auto/AGENT_STDOUT.txt

      - name: Enforce policy removals on merge branch (images + caches + purge_globs)
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.CODE_GH_PAT || github.token }}
          REPO: ${{ github.repository }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          OWNER=${REPO%%/*}
          REPO_N=${REPO##*/}
          # Only proceed if branch exists
          if ! git ls-remote --exit-code --heads origin upstream-merge >/dev/null 2>&1; then
            echo "upstream-merge branch not found; skipping policy cleanup"; exit 0
          fi
          wt=.wt-upstream-merge-clean
          rm -rf "$wt" && git worktree add -f "$wt" origin/upstream-merge
          pushd "$wt" >/dev/null
          removed=false
          # Remove any accidentally committed merge artifacts from repo root
          for f in MERGE_PLAN.md MERGE_REPORT.md; do
            if git ls-files -- "$f" | grep -q .; then git rm -f -- "$f"; removed=true; fi
          done
          # Remove any accidentally committed artifacts under .github/auto/** (these should be uploaded, not tracked)
          auto_tracked=$(git ls-files -- '.github/auto/**' || true)
          if [ -n "$auto_tracked" ]; then echo "$auto_tracked" | xargs -r git rm -f --; removed=true; fi
          # Remove any tracked upstream images disallowed by local policy
          for p in .github/codex-cli-*.png .github/codex-cli-*.jpg .github/codex-cli-*.jpeg .github/codex-cli-*.webp; do
            files=$(git ls-files -- "$p" || true)
            if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
          done
          # Belt-and-suspenders: drop any accidentally committed cargo cache dirs
          # Cover both repo-root and nested workspace (e.g., codex-rs/.cargo-home)
          for d in .cargo-home .cargo2 codex-rs/.cargo-home codex-rs/.cargo2; do
            files=$(git ls-files -- "$d/**" || true)
            if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
          done
          # Drop any codex-rs/<crate> directories that do not exist on the default branch (we removed/renamed them locally)
          DEF_REF="origin/${DEFAULT_BRANCH}"
          # Collect crate dirs on default and on current worktree
          mapfile -t default_crates < <(git ls-tree -r --name-only "$DEF_REF" | awk -F'/' '/^codex-rs\//{print $1"/"$2}' | sort -u)
          mapfile -t branch_crates  < <(git ls-files | awk -F'/' '/^codex-rs\//{print $1"/"$2}' | sort -u)
          for c in "${branch_crates[@]}"; do
            keep=0
            for d in "${default_crates[@]}"; do [ "$c" = "$d" ] && keep=1 && break; done
            if [ $keep -eq 0 ]; then
              files=$(git ls-files -- "$c/**" || true)
              if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
            fi
          done
          # Apply purge_globs and perma_removed_paths from merge-policy.json when present
          if command -v jq >/dev/null 2>&1 && [ -f ".github/merge-policy.json" ]; then
            mapfile -t purges < <(jq -r '.purge_globs[]? // empty' .github/merge-policy.json 2>/dev/null || true)
            mapfile -t perma  < <(jq -r '.perma_removed_paths[]? // empty' .github/merge-policy.json 2>/dev/null || true)
            for pat in "${purges[@]}" "${perma[@]}"; do
              [ -n "${pat:-}" ] || continue
              files=$(git ls-files -- "$pat" || true)
              if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
            done
          fi
          # Remove any reintroduced paths detected during precompute
          if [ -f "$GITHUB_WORKSPACE/.github/auto/REINTRODUCED_PATHS.txt" ]; then
            mapfile -t reintro < "$GITHUB_WORKSPACE/.github/auto/REINTRODUCED_PATHS.txt" || true
            if [ ${#reintro[@]} -gt 0 ]; then
              files=$(git ls-files -- "${reintro[@]}" || true)
              if [ -n "$files" ]; then echo "$files" | xargs -r git rm -f --; removed=true; fi
            fi
          fi
          if [ "$removed" = true ]; then
            git -c user.email="github-actions[bot]@users.noreply.github.com" -c user.name="github-actions[bot]" \
              commit -m "chore(merge): enforce policy removals (images + cargo caches)"
            git push origin HEAD:upstream-merge
          fi
          popd >/dev/null
          git worktree remove -f "$wt"
      
      - name: Policy guard checks (docs, branding, perma-deleted)
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          # Fail if docs/** changed between default and upstream-merge (we prefer ours)
          changed=$(git diff --name-only "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- 'docs/**' | wc -l | tr -d ' ')
          if [ "$changed" != "0" ]; then
            echo "docs/** changed on upstream-merge; policy prefers ours. Failing." >&2
            git diff --name-only "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- 'docs/**' >&2 || true
            exit 1
          fi
          # Branding guard: block additions of user-visible 'Codex' in TUI/CLI/docs (allow crate/package contexts)
          if git diff -U0 --no-color "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- codex-rs/tui/** codex-cli/** docs/** \
            | grep -E '^\+' \
            | grep -Ei '\bCodex\b' \
            | grep -Evi '(codex-rs|codex-[a-z0-9_-]+|https?://|Cargo|crate|package|workspace)' >/dev/null 2>&1; then
            echo "Branding guard tripped: new user-visible 'Codex' strings detected in TUI/CLI/docs." >&2
            git diff -U0 --no-color "origin/${DEFAULT_BRANCH}..origin/upstream-merge" -- codex-rs/tui/** codex-cli/** docs/** \
              | grep -E '^\+' | grep -Ei '\bCodex\b' | sed 's/^/> /' >&2 || true
            exit 1
          fi
          # Perma-deleted guard: ensure none of perma_removed_paths exist on branch
          if command -v jq >/dev/null 2>&1 && [ -f ".github/merge-policy.json" ]; then
            mapfile -t perma  < <(jq -r '.perma_removed_paths[]? // empty' .github/merge-policy.json 2>/dev/null || true)
            if [ ${#perma[@]} -gt 0 ]; then
              wt=.wt-guard
              rm -rf "$wt" && git worktree add -f "$wt" origin/upstream-merge >/dev/null
              pushd "$wt" >/dev/null
              for pat in "${perma[@]}"; do
                [ -n "${pat:-}" ] || continue
                if git ls-files -- "$pat" | grep -q .; then
                  echo "Perma-deleted guard: files present matching '$pat'" >&2
                  git ls-files -- "$pat" >&2 || true
                  exit 1
                fi
              done
              popd >/dev/null
              git worktree remove -f "$wt" >/dev/null
            fi
          fi

      - name: TUI invariants guard (strict stream ordering keys)
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        run: |
          set -euo pipefail
          # Only run if upstream delta touched TUI
          if ! grep -q '^codex-rs/tui/' .github/auto/DELTA_FILES.txt 2>/dev/null; then
            echo "No TUI changes in upstream delta; skipping invariants guard."; exit 0
          fi
          # Verify critical ordering identifiers exist somewhere under codex-rs/tui/
          failed=0
          for token in request_ordinal output_index sequence_number; do
            if ! git ls-tree -r --name-only origin/upstream-merge -- 'codex-rs/tui/**' | while read -r f; do git show "origin/upstream-merge:$f" || true; done | grep -q "$token"; then
              echo "::warning::Invariant token '$token' not found under codex-rs/tui on upstream-merge (non-blocking)." >&2
            fi
          done

      - name: Summarize run
        if: steps.check_upstream.outputs.skip != 'true'
        env:
          MERGE_MODE: ${{ steps.prep.outputs.merge_mode || 'one-shot' }}
          NO_MERGE_BASE: ${{ steps.prep.outputs.no_merge_base || 'false' }}
        run: |
          set -euo pipefail
          echo "### Upstream Merge Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "- Mode: ${MERGE_MODE}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Files changed upstream: ${{ steps.prep.outputs.files_count }} (est. LOC: ${{ steps.prep.outputs.loc_est }})" >> "$GITHUB_STEP_SUMMARY"
          echo "- Branch: upstream-merge" >> "$GITHUB_STEP_SUMMARY"
          echo "- Artifacts: COMMITS.json, MERGE_PLAN.md, MERGE_REPORT.md, DIFFSTAT.txt" >> "$GITHUB_STEP_SUMMARY"
          if [ "${NO_MERGE_BASE}" = "true" ]; then echo "- Note: upstream/default have no merge-base (unrelated histories)." >> "$GITHUB_STEP_SUMMARY"; fi
          # Preview small artifacts inline for quick debugging
          for f in COMMITS.json CHANGE_HISTOGRAM.txt DIFFSTAT.txt REINTRODUCED_PATHS.txt; do
            p=".github/auto/$f"; [ -s "$p" ] || continue; echo "\n#### $f" >> "$GITHUB_STEP_SUMMARY"; echo '\n```' >> "$GITHUB_STEP_SUMMARY"; sed -n '1,120p' "$p" >> "$GITHUB_STEP_SUMMARY"; echo '```' >> "$GITHUB_STEP_SUMMARY"; done

      # Upload each artifact separately so they appear as individual items in the UI
      - name: Upload artifact - COMMITS.json
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: COMMITS.json
          if-no-files-found: warn
          path: .github/auto/COMMITS.json

      - name: Upload artifact - DELTA_FILES.txt
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: DELTA_FILES.txt
          if-no-files-found: warn
          path: .github/auto/DELTA_FILES.txt

      - name: Upload artifact - DIFFSTAT.txt
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: DIFFSTAT.txt
          if-no-files-found: warn
          path: .github/auto/DIFFSTAT.txt

      - name: Upload artifact - CHANGE_HISTOGRAM.txt
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: CHANGE_HISTOGRAM.txt
          if-no-files-found: warn
          path: .github/auto/CHANGE_HISTOGRAM.txt

      - name: Upload artifact - DELETED_ON_DEFAULT.txt
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: DELETED_ON_DEFAULT.txt
          if-no-files-found: warn
          path: .github/auto/DELETED_ON_DEFAULT.txt

      - name: Upload artifact - REINTRODUCED_PATHS.txt
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: REINTRODUCED_PATHS.txt
          if-no-files-found: warn
          path: .github/auto/REINTRODUCED_PATHS.txt

      - name: Upload artifact - MERGE_PLAN.md
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: MERGE_PLAN.md
          if-no-files-found: warn
          path: .github/auto/MERGE_PLAN.md

      - name: Upload artifact - MERGE_REPORT.md
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: MERGE_REPORT.md
          if-no-files-found: warn
          path: .github/auto/MERGE_REPORT.md
      - name: Open or update PR (use agent-supplied title/body if present)
        if: steps.check_upstream.outputs.skip != 'true'
        uses: actions/github-script@v7
        env:
          MERGE_BRANCH: ${{ env.MERGE_BRANCH }}
          UPSTREAM_REPO: ${{ env.UPSTREAM_REPO }}
          UPSTREAM_BRANCH: ${{ env.UPSTREAM_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        with:
          github-token: ${{ secrets.CODE_GH_PAT || github.token }}
          script: |
            const fs = require('fs');
            function readOrDefault(p, dflt) { try { const t = fs.readFileSync(p,'utf8').trim(); return t || dflt; } catch { return dflt; } }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = process.env.MERGE_BRANCH;
            const base = process.env.DEFAULT_BRANCH;
            const dfltTitle = `Upstream merge: ${process.env.UPSTREAM_REPO}@${process.env.UPSTREAM_BRANCH} into ${base}`;
            const title = readOrDefault('.github/auto/PR_TITLE.txt', dfltTitle);
            let body = readOrDefault('.github/auto/PR_BODY.md', '');
            if (!body) {
              body = `This PR merges ${process.env.UPSTREAM_REPO}@${process.env.UPSTREAM_BRANCH} into ${base}.`;
            }
            // Ensure the branch exists on origin before creating/updating a PR.
            const ref = `heads/${head}`;
            try {
              await github.rest.git.getRef({ owner, repo, ref });
            } catch (e) {
              core.notice(`Branch '${head}' not found on origin; skipping PR creation.`);
              return;
            }
            // Skip PR if there are no net file changes vs base. Close existing PR if present.
            let zeroDiff = false;
            try {
              const cmp = await github.rest.repos.compareCommitsWithBasehead({ owner, repo, basehead: `${base}...${head}` });
              const files = cmp.data.files || [];
              // Consider zero-diff if no files changed. This handles merges that add commits but no file deltas.
              zeroDiff = files.length === 0;
            } catch (e) {
              core.warning(`Compare failed (${base}...${head}): ${e.message}. Proceeding to PR creation.`);
            }
            const headRef = `${owner}:${head}`;
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: headRef });
            if (zeroDiff) { core.notice('Zero diff vs base; skipping PR creation.'); return; }
            if (prs.data.length) {
              const pr = prs.data[0];
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, title, body });
              core.notice(`Updated PR #${pr.number}`);
            } else {
              const pr = await github.rest.pulls.create({ owner, repo, title, head: headRef, base, body });
              core.notice(`Created PR #${pr.data.number}`);
            }

      - name: Close stale upstream-merge PR on skip when zero diff
        if: steps.check_upstream.outputs.skip == 'true'
        uses: actions/github-script@v7
        env:
          MERGE_BRANCH: ${{ env.MERGE_BRANCH }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || 'main' }}
        with:
          github-token: ${{ secrets.CODE_GH_PAT || github.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const head = process.env.MERGE_BRANCH;
            const base = process.env.DEFAULT_BRANCH;
            const headRef = `${owner}:${head}`;
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: headRef });
            if (!prs.data.length) { return; }
            // Only close if zero diff after we reset upstream-merge
            let zeroDiff = false;
            try {
              const cmp = await github.rest.repos.compareCommitsWithBasehead({ owner, repo, basehead: `${base}...${head}` });
              zeroDiff = (cmp.data.files || []).length === 0;
            } catch (e) {
              core.warning(`Compare failed (${base}...${head}): ${e.message}. Skipping.`);
              return;
            }
            if (zeroDiff) {
              const pr = prs.data[0];
              await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body: 'Closing: upstream merge has no net file changes vs base.' });
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, state: 'closed' });
              core.notice(`Closed PR #${pr.number} due to zero diff (skip path).`);
            }
