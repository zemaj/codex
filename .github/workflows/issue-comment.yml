name: Issue Comment (Preview)

on:
  # Automatic: when Preview Build finishes successfully for a PR
  workflow_run:
    workflows: ["Preview Build"]
    types: [completed]
  # Manual: allow maintainers to trigger for a specific PR
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to post preview comment to linked issue"
        required: true
        type: number

concurrency:
  group: issue-comment-${{ github.event_name == 'workflow_dispatch' && inputs.pr_number || github.event.workflow_run.id }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: read
  actions: read

jobs:
  comment:
    name: Post preview instructions to linked issue
    if: >-
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.event == 'pull_request' &&
       github.event.workflow_run.conclusion == 'success')
      || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest

    steps:
      - name: Resolve PR + Issue
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Determine PR number from workflow_run payload or manual input
            let prNumber = 0;
            if (context.eventName === 'workflow_run') {
              const wr = context.payload.workflow_run;
              const prs = Array.isArray(wr.pull_requests) ? wr.pull_requests : [];
              if (prs.length) prNumber = prs[0].number;
            } else {
              prNumber = Number((context.payload.inputs && context.payload.inputs.pr_number) || 0);
            }
            if (!prNumber) {
              core.setFailed('Unable to resolve PR number.');
              return;
            }

            // Fetch PR details
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

            // Try to derive issue number from head branch (issue-123), PR body/title references, or linked issues
            let issueNumber = 0;
            const branch = pr.head.ref || '';
            const m = branch.match(/^issue-(\d+)$/);
            if (m) issueNumber = Number(m[1]);

            function findIssueRef(text) {
              if (!text) return 0;
              // Prefer explicit forms like "Closes #123" or "#123"
              const rx = /(close[sd]?|fix(e[sd])?|resolve[sd]?)?\s*#(\d{1,6})/ig;
              let best = 0; let mm;
              while ((mm = rx.exec(text))) { best = Number(mm[3]); }
              return best;
            }
            if (!issueNumber) issueNumber = findIssueRef(pr.body);
            if (!issueNumber) issueNumber = findIssueRef(pr.title);

            // Quick fallback: search issues mentioning the PR number (rarely needed)
            if (!issueNumber) {
              try {
                const q = `repo:${owner}/${repo} is:issue ${pr.number}`;
                const s = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
                const hit = s.data.items.find(i => i.pull_request == null);
                if (hit) issueNumber = hit.number;
              } catch {}
            }

            // Collect a compact file summary for context
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber, per_page: 100 });
            const changed = files.map(f => `- ${f.status.padEnd(6)} ${f.filename}`).slice(0, 50);

            // Issue author
            let issueAuthor = '';
            if (issueNumber) {
              try {
                const { data: iss } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                issueAuthor = iss.user?.login || '';
              } catch {}
            }

            // Collect latest commit subjects on the PR (brief)
            let commits = [];
            try {
              const all = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: prNumber, per_page: 100 });
              commits = all.slice(-5).map(c => `- ${c.commit.message.split('\n')[0]}`);
            } catch {}

            core.setOutput('pr_number', String(prNumber));
            core.setOutput('issue_number', String(issueNumber || 0));
            core.setOutput('title', pr.title || '');
            core.setOutput('body', pr.body || '');
            core.setOutput('head', pr.head.ref || '');
            core.setOutput('base', pr.base.ref || '');
            core.setOutput('changed', changed.join('\n'));
            core.setOutput('commits', commits.join('\n'));
            core.setOutput('issue_author', issueAuthor);

      - name: Prepare context file
        id: ctx
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.meta.outputs.pr_number }}
          TITLE: ${{ steps.meta.outputs.title }}
          BODY: ${{ steps.meta.outputs.body }}
          CHANGED: ${{ steps.meta.outputs.changed }}
          COMMITS: ${{ steps.meta.outputs.commits }}
          ISSUE_AUTHOR: ${{ steps.meta.outputs.issue_author }}
          ISSUE_NUMBER: ${{ steps.meta.outputs.issue_number }}
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner; const repo = context.repo.repo;
            const pr = Number(process.env.PR_NUMBER);
            const issue_number = Number(process.env.ISSUE_NUMBER || 0);
            // resolve slug
            const { data: pull } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
            const marker = /<!--\s*codex-id:\s*([a-z0-9-]{3,})\s*-->/i;
            let slug = '';
            const m = (pull.body || '').match(marker);
            if (m) slug = m[1].toLowerCase();
            if (!slug) {
              const b = pull.head.ref || '';
              const im = b.match(/^issue-(\d+)$/); let issue_number = 0; if (im) issue_number = Number(im[1]);
              if (issue_number) {
                const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
                for (const c of comments) { const mm = (c.body || '').match(marker); if (mm) { slug = mm[1].toLowerCase(); break; } }
              }
            }
            if (!slug) throw new Error('Missing codex-id marker on PR/issue.');
            // resolve latest tag for slug
            const baseTag = `preview-${slug}`;
            const rels = await github.paginate(github.rest.repos.listReleases, { owner, repo, per_page: 100 });
            let tag = baseTag; let maxN = 0; let hasBase = false;
            for (const r of rels) {
              const t = r.tag_name || '';
              if (t === baseTag) { hasBase = true; maxN = Math.max(maxN, 1); tag = baseTag; }
              const mm = t.match(new RegExp(`^${baseTag}-(\\d+)$`));
              if (mm) { const n = parseInt(mm[1], 10); if (n > maxN) { maxN = n; tag = t; } }
            }
            const releaseBase = `https://github.com/${owner}/${repo}/releases/download/${tag}`;
            const lines = [];
            lines.push(`# PR #${pr}: ${process.env.TITLE || ''}`);
            lines.push('');
            lines.push(`PR: https://github.com/${owner}/${repo}/pull/${pr}`);
            lines.push('');
            if ((process.env.BODY || '').trim()) {
              lines.push('## PR body');
              lines.push(process.env.BODY.trim());
              lines.push('');
            }
            if ((process.env.CHANGED || '').trim()) {
              lines.push('## Changed files (first 50)');
              lines.push(process.env.CHANGED.trim());
              lines.push('');
            }
            // Commit subjects and links
            try {
              const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: pr, per_page: 100 });
              const recent = commits.slice(-5);
              if (recent.length) {
                lines.push('## What changed in this build (recent commits)');
                lines.push(recent.map(c => `- ${c.commit.message.split('\n')[0]}`).join('\n'));
                lines.push('');
                lines.push('## Commit links');
                lines.push(recent.map(c => `- ${c.commit.message.split('\n')[0]} (${c.sha.substring(0,7)}): https://github.com/${owner}/${repo}/commit/${c.sha}`).join('\n'));
                lines.push('');
              }
            } catch {}
            // Issue body and recent comments for agent context
            if (issue_number) {
              try {
                const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
                lines.push('## Issue #'+issue_number+' context');
                lines.push('### Issue body');
                lines.push((issue.body || '').trim());
                lines.push('');
                const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
                if (comments.length) {
                  lines.push('### Recent issue comments (newest first, up to 10)');
                  const last = comments.slice(-10).reverse();
                  for (const c of last) {
                    const when = (c.created_at || '').replace('T',' ').replace('Z','');
                    lines.push(`- [@${c.user?.login||'unknown'} at ${when}]`);
                    const body = (c.body || '').trim();
                    lines.push(body.length > 1200 ? body.slice(0,1200)+"\n…" : body);
                    lines.push('');
                  }
                }
              } catch {}
            }
            lines.push('## Preview command');
            lines.push('```bash');
            lines.push(`code preview ${slug}`);
            lines.push('```');
            lines.push('');
            lines.push(`Issue author: @${process.env.ISSUE_AUTHOR || ''}`);
            fs.mkdirSync('.github/auto', { recursive: true });
            fs.writeFileSync('.github/auto/ISSUE_PREVIEW_CONTEXT.md', lines.join('\n'));

      - name: Start local OpenAI proxy (optional)
        if: env.OPENAI_API_KEY != ''
        id: proxy
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          cat > .github/auto/openai-proxy.js <<'JS'
          const http = require('http');
          const https = require('https');
          const { URL } = require('url');
          const PORT = process.env.PORT || 5056;
          const API_KEY = process.env.OPENAI_API_KEY || '';
          const ALLOWED = ['/v1/chat/completions','/v1/responses'];
          if (!API_KEY) { process.exit(0); }
          const server = http.createServer((req, res) => {
            if (req.method !== 'POST' || !ALLOWED.some(p => req.url.startsWith(p))) {
              res.writeHead(403, { 'content-type': 'application/json' });
              res.end(JSON.stringify({ error: 'blocked' }));
              return;
            }
            const chunks = [];
            req.on('data', c => { chunks.push(c); if (Buffer.concat(chunks).length > 1024*1024) req.destroy(); });
            req.on('end', () => {
              const up = new URL('https://api.openai.com' + req.url);
              const fw = https.request({ method: 'POST', hostname: up.hostname, path: up.pathname + up.search, headers: { 'content-type': 'application/json', 'authorization': `Bearer ${API_KEY}` } }, r => { res.writeHead(r.statusCode || 500, r.headers); r.pipe(res); });
              fw.on('error', e => { res.writeHead(502, {'content-type':'application/json'}); res.end(JSON.stringify({ error:'upstream', message: e.message })); });
              fw.end(Buffer.concat(chunks));
            });
          });
          server.listen(PORT, '127.0.0.1', () => { console.log('proxy listening on 127.0.0.1:'+PORT); });
          JS
          node .github/auto/openai-proxy.js > .github/auto/openai-proxy.log 2>&1 &

      - name: Generate comment with Code (read-only)
        id: gen
        continue-on-error: true
        env:
          ISSUE_AUTHOR: ${{ steps.meta.outputs.issue_author }}
        run: |
          set -euo pipefail
          SAFE_PATH="$PATH"; SAFE_HOME="$HOME";
          PROMPT=$(cat <<EOP
          <task>
          You are writing an enthusiastic, user‑facing issue reply about a successful preview build. Please do not assume the user has deep technical knowledge.
          Use the following template, but adapt all language to this specific change. Be friendly and curious where appropriate.
          You MAY remove sections that repeat earlier replies.

          TEMPLATE (example):
          ---
          @user Thanks for the great feature request! Changing the title is an interesting personalization and ties in really well with our existing theme options. [Replace this sentence with specific feedback to the user and reference their idea. Always start by mentioning them.]

          I’ve added the ability to edit the title from the /theme slash command, since that’s where the existing theme functionality lives. [Explain in simple, non‑technical language what changed.]

          You can run this right now—can’t wait for you to try it! In your terminal, run: [Be excited but concise.]
          ```
          code preview <slug here>
          ```
          Then run /theme in the terminal to see the new option. [Explain how to try it once launched.]

          Can’t wait for you to try changing your title! Please comment here if it’s working well or needs tweaks. Maintainers will review and, if merged into a release, you’ll get an update here. Thanks again! [Positive, personable close.]

          Changes made:
          - Added title customization [Summarize notable change(s).]

          Commits:
          - [Link to any commits]
          ---

          REQUIREMENTS:
          - Replace @user with the actual GitHub handle(s) of the person you are replying to (either the issue author and/or last commenter).
          - Replace <slug here> with the exact preview command from the context below.
          - In the changes made section, include links to the commit if possible.
          - Keep it brief, clear, and kind.
          </task>
          <context>
          $(cat .github/auto/ISSUE_PREVIEW_CONTEXT.md)
          </context>
          Output ONLY:
          <comment>
          …final Markdown comment…
          </comment>
          EOP
          )
          set +e
          { printf '%s' "$PROMPT" | env -i PATH="$SAFE_PATH" HOME="$SAFE_HOME" \
              OPENAI_API_KEY="x" OPENAI_BASE_URL="http://127.0.0.1:5056/v1" \
              npx -y @just-every/code@latest exec -s read-only --cd "$GITHUB_WORKSPACE" --skip-git-repo-check -; } \
            2>&1 | tee .github/auto/AGENT_OUT.txt
          true
          set -e
          node - <<'JS'
          const fs = require('fs');
          const t = fs.readFileSync('.github/auto/AGENT_OUT.txt','utf8');
          const all = [...t.matchAll(/<comment>([\s\S]*?)<\/comment>/gi)];
          const PLACEHOLDER = '…final Markdown comment…';
          let body = '';
          if (all.length) {
            const last = (all[all.length-1][1] || '').trim();
            if (last && last !== PLACEHOLDER) body = last;
          }
          if (body) {
            fs.writeFileSync('.github/auto/ISSUE_COMMENT.md', body + '\n');
          }
          JS

      - name: Post comment to linked issue (upsert by marker; fallback to stock)
        uses: actions/github-script@v7
        env:
          ISSUE_NUMBER: ${{ steps.meta.outputs.issue_number }}
          PR_NUMBER: ${{ steps.meta.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner; const repo = context.repo.repo;
            const issue_number = Number(process.env.ISSUE_NUMBER || 0);
            const pr = Number(process.env.PR_NUMBER || 0);
            if (!issue_number) { core.notice('No linked issue detected; skipping issue comment.'); return; }
            const ISSUE_MARK = '<!-- preview-build:issue -->';
            let body = '';
            try { body = fs.readFileSync('.github/auto/ISSUE_COMMENT.md','utf8').trim(); } catch {}
            const PLACEHOLDER = '…final Markdown comment…';
            if (body && body.includes(PLACEHOLDER)) { body = ''; }
            if (!body) {
              // derive slug + latest tag
              const { data: pull } = await github.rest.pulls.get({ owner, repo, pull_number: pr });
              const slugRe = /<!--\s*codex-id:\s*([a-z0-9-]{3,})\s*-->/i;
              let slug = '';
              const m = (pull.body || '').match(slugRe);
              if (m) slug = m[1].toLowerCase();
              if (!slug) {
                const b = pull.head.ref || '';
                const im = b.match(/^issue-(\d+)$/); let issue_number2 = 0; if (im) issue_number2 = Number(im[1]);
                if (issue_number2) {
                  const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: issue_number2, per_page: 100 });
                  for (const c of comments) { const mm = (c.body || '').match(slugRe); if (mm) { slug = mm[1].toLowerCase(); break; } }
                }
              }
              const baseTag = `preview-${slug}`;
              const rels = await github.paginate(github.rest.repos.listReleases, { owner, repo, per_page: 100 });
              let tag = baseTag; let maxN = 0; let hasBase = false;
              for (const r of rels) {
                const t = r.tag_name || '';
                if (t === baseTag) { hasBase = true; maxN = Math.max(maxN, 1); tag = baseTag; }
                const mm = t.match(new RegExp(`^${baseTag}-(\\d+)$`));
                if (mm) { const n = parseInt(mm[1], 10); if (n > maxN) { maxN = n; tag = t; } }
              }
              const base = `https://github.com/${owner}/${repo}/releases/download/${tag}`;
              // Pull a short commit summary for this PR
              let commits = [];
              try {
                const all = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: pr, per_page: 100 });
                commits = all.slice(-5).map(c => `- ${c.commit.message.split('\n')[0]}`);
              } catch {}
              // Synthesized fallback matching the template (no direct downloads)
              const issueAuthor = `${{ steps.meta.outputs.issue_author }}` || '';
              body = [
                ISSUE_MARK,
                `@${issueAuthor} Thanks for the great request — a preview is ready!`,
                '',
                'You can run it right now:',
                '```bash',
                `code preview ${slug}`,
                '```',
                '',
                'Please let us know here if it works well or needs tweaks. Maintainers will review and, if merged, you’ll get an update here. Thanks again! ',
                '',
                commits.length ? 'Changes made:' : '',
                commits.length ? commits.join('\n') : '',
                ISSUE_MARK
              ].filter(Boolean).join('\n');
            }
            // Upsert by marker on the issue
            const all = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
            const mine = all.find(c => c.user?.type?.toLowerCase().includes('bot') && (c.body || '').includes(ISSUE_MARK));
            if (mine) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: mine.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }
